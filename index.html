<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body, html {
            width: 100%;
            height: 100%;
            background: #000;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="fluid-canvas"></canvas>

    <script>
        class FluidSimulation {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Simulation parameters
                this.GRID_SIZE = 100;
                this.iterations = 16;
                this.timeStep = 0.1;
                this.diffusion = 0.0001;
                this.viscosity = 0.000015;
                
                // Create simulation grid
                this.N = this.GRID_SIZE;
                this.size = (this.N + 2) * (this.N + 2);
                
                // Velocity and density fields
                this.velocityX = new Array(this.size).fill(0);
                this.velocityY = new Array(this.size).fill(0);
                this.velocityX0 = new Array(this.size).fill(0);
                this.velocityY0 = new Array(this.size).fill(0);
                this.density = new Array(this.size).fill(0);
                this.density0 = new Array(this.size).fill(0);
                
                // Handle mouse/touch interaction
                this.pointers = [];
                this.lastX = 0;
                this.lastY = 0;
                this.setupEvents();
                
                // Start animation loop
                this.tick();
                
                // Add initial fluid
                setTimeout(() => {
                    this.addFluidSources();
                    setInterval(() => this.addRandomSplat(), 2000);
                }, 100);
            }
            
            // Utility function to convert 2D coordinates to array index
            IX(x, y) {
                return x + (this.N + 2) * y;
            }
            
            // Boundary conditions handling
            setBoundary(b, x) {
                // Handle boundaries (walls)
                for (let i = 1; i <= this.N; i++) {
                    x[this.IX(0, i)] = b === 1 ? -x[this.IX(1, i)] : x[this.IX(1, i)];
                    x[this.IX(this.N + 1, i)] = b === 1 ? -x[this.IX(this.N, i)] : x[this.IX(this.N, i)];
                    x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
                    x[this.IX(i, this.N + 1)] = b === 2 ? -x[this.IX(i, this.N)] : x[this.IX(i, this.N)];
                }
                
                // Handle corners
                x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
                x[this.IX(0, this.N + 1)] = 0.5 * (x[this.IX(1, this.N + 1)] + x[this.IX(0, this.N)]);
                x[this.IX(this.N + 1, 0)] = 0.5 * (x[this.IX(this.N, 0)] + x[this.IX(this.N + 1, 1)]);
                x[this.IX(this.N + 1, this.N + 1)] = 0.5 * (x[this.IX(this.N, this.N + 1)] + x[this.IX(this.N + 1, this.N)]);
            }
            
            // Linear solver for diffusion and viscosity
            linearSolve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                
                for (let k = 0; k < this.iterations; k++) {
                    for (let j = 1; j <= this.N; j++) {
                        for (let i = 1; i <= this.N; i++) {
                            x[this.IX(i, j)] = (x0[this.IX(i, j)] + a * (
                                x[this.IX(i + 1, j)] + x[this.IX(i - 1, j)] +
                                x[this.IX(i, j + 1)] + x[this.IX(i, j - 1)]
                            )) * cRecip;
                        }
                    }
                    
                    this.setBoundary(b, x);
                }
            }
            
            // Diffusion step
            diffuse(b, x, x0, diffusion) {
                const a = this.timeStep * diffusion * this.N * this.N;
                this.linearSolve(b, x, x0, a, 1 + 4 * a);
            }
            
            // Advection step - move density or velocity through the fluid
            advect(b, d, d0, u, v) {
                let i0, j0, i1, j1;
                let x, y, s0, t0, s1, t1;
                
                const dt0 = this.timeStep * this.N;
                
                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        // Trace particle backwards
                        x = i - dt0 * u[this.IX(i, j)];
                        y = j - dt0 * v[this.IX(i, j)];
                        
                        // Ensure we stay within boundaries
                        if (x < 0.5) x = 0.5;
                        if (x > this.N + 0.5) x = this.N + 0.5;
                        if (y < 0.5) y = 0.5;
                        if (y > this.N + 0.5) y = this.N + 0.5;
                        
                        // Find grid cells for bilinear interpolation
                        i0 = Math.floor(x);
                        i1 = i0 + 1;
                        j0 = Math.floor(y);
                        j1 = j0 + 1;
                        
                        // Interpolation weights
                        s1 = x - i0;
                        s0 = 1 - s1;
                        t1 = y - j0;
                        t0 = 1 - t1;
                        
                        // Bilinear interpolation
                        d[this.IX(i, j)] = 
                            s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
                            s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                    }
                }
                
                this.setBoundary(b, d);
            }
            
            // Project velocity field to make it mass-conserving (incompressible)
            project(u, v, p, div) {
                // Calculate divergence
                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        div[this.IX(i, j)] = -0.5 * (
                            u[this.IX(i + 1, j)] - u[this.IX(i - 1, j)] +
                            v[this.IX(i, j + 1)] - v[this.IX(i, j - 1)]
                        ) / this.N;
                        p[this.IX(i, j)] = 0;
                    }
                }
                
                this.setBoundary(0, div);
                this.setBoundary(0, p);
                
                // Solve Poisson equation
                this.linearSolve(0, p, div, 1, 4);
                
                // Project velocity field
                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        u[this.IX(i, j)] -= 0.5 * this.N * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]);
                        v[this.IX(i, j)] -= 0.5 * this.N * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]);
                    }
                }
                
                this.setBoundary(1, u);
                this.setBoundary(2, v);
            }
            
            // Single step of the fluid simulation
            step() {
                // Diffuse velocities
                this.diffuse(1, this.velocityX0, this.velocityX, this.viscosity);
                this.diffuse(2, this.velocityY0, this.velocityY, this.viscosity);
                
                // Project for incompressibility
                this.project(this.velocityX0, this.velocityY0, this.velocityX, this.velocityY);
                
                // Advect velocities
                this.advect(1, this.velocityX, this.velocityX0, this.velocityX0, this.velocityY0);
                this.advect(2, this.velocityY, this.velocityY0, this.velocityX0, this.velocityY0);
                
                // Project again
                this.project(this.velocityX, this.velocityY, this.velocityX0, this.velocityY0);
                
                // Diffuse and advect density
                this.diffuse(0, this.density0, this.density, this.diffusion);
                this.advect(0, this.density, this.density0, this.velocityX, this.velocityY);
            }
            
            // Rendering loop
            tick() {
                this.step();
                this.render();
                requestAnimationFrame(() => this.tick());
            }
            
            // Handle density and velocity addition from external forces (mouse)
            addForce(x, y, amountX, amountY) {
                const cellX = Math.floor((x / this.canvas.width) * this.N) + 1;
                const cellY = Math.floor((y / this.canvas.height) * this.N) + 1;
                
                if (cellX < 1 || cellX > this.N || cellY < 1 || cellY > this.N) {
                    return;
                }
                
                // Add velocity
                this.velocityX[this.IX(cellX, cellY)] += amountX * 100;
                this.velocityY[this.IX(cellX, cellY)] += amountY * 100;
            }
            
            // Add density to a cell
            addDensity(x, y, amount) {
                const cellX = Math.floor((x / this.canvas.width) * this.N) + 1;
                const cellY = Math.floor((y / this.canvas.height) * this.N) + 1;
                
                if (cellX < 1 || cellX > this.N || cellY < 1 || cellY > this.N) {
                    return;
                }
                
                // Add density
                this.density[this.IX(cellX, cellY)] += amount;
            }
            
            // Add initial fluid sources
            addFluidSources() {
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    
                    this.addDensity(x, y, 200);
                    this.addForce(x, y, Math.random() * 20 - 10, Math.random() * 20 - 10);
                }
            }
            
            // Add a random splat periodically
            addRandomSplat() {
                const x = Math.random() * this.canvas.width;
                const y = Math.random() * this.canvas.height;
                
                this.addDensity(x, y, 500);
                this.addForce(x, y, Math.random() * 50 - 25, Math.random() * 50 - 25);
            }
            
            // Render fluid to canvas
            render() {
                // Create image data
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Scale factors
                const cellWidth = this.canvas.width / this.N;
                const cellHeight = this.canvas.height / this.N;
                
                // Render fluid densities
                for (let j = 0; j < this.canvas.height; j++) {
                    for (let i = 0; i < this.canvas.width; i++) {
                        // Map canvas pixel to fluid grid cell
                        const x = Math.min(Math.floor(i / cellWidth), this.N);
                        const y = Math.min(Math.floor(j / cellHeight), this.N);
                        
                        // Get density at this cell
                        const d = this.density[this.IX(x, y)];
                        const velocity = Math.sqrt(
                            this.velocityX[this.IX(x, y)] * this.velocityX[this.IX(x, y)] +
                            this.velocityY[this.IX(x, y)] * this.velocityY[this.IX(x, y)]
                        );
                        
                        // Convert density to color (more vibrant colors)
                        const pixelIndex = (j * this.canvas.width + i) * 4;
                        
                        // Blue-cyan-purple fluid color scheme
                        const r = Math.min(255, d * 0.2 + velocity * 5);
                        const g = Math.min(255, d * 0.4 + velocity * 10); 
                        const b = Math.min(255, d * 1.0 + velocity * 5);
                        
                        data[pixelIndex] = r;
                        data[pixelIndex + 1] = g;
                        data[pixelIndex + 2] = b;
                        data[pixelIndex + 3] = Math.min(255, d * 2); // Alpha (opacity)
                    }
                }
                
                // Put the image data on the canvas
                this.ctx.putImageData(imageData, 0, 0);
            }
            
            // Set up event listeners for interaction
            setupEvents() {
                // Mouse events
                this.canvas.addEventListener('mousedown', e => {
                    this.pointers.push({
                        id: -1,
                        x: e.offsetX,
                        y: e.offsetY,
                        px: e.offsetX,
                        py: e.offsetY
                    });
                });
                
                this.canvas.addEventListener('mousemove', e => {
                    if (this.pointers.length > 0) {
                        const pointer = this.pointers[0];
                        pointer.px = pointer.x;
                        pointer.py = pointer.y;
                        pointer.x = e.offsetX;
                        pointer.y = e.offsetY;
                        
                        this.addDensity(pointer.x, pointer.y, 200);
                        
                        const dx = pointer.x - pointer.px;
                        const dy = pointer.y - pointer.py;
                        this.addForce(pointer.x, pointer.y, dx, dy);
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.pointers = [];
                });
                
                // Touch events
                this.canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        this.pointers.push({
                            id: touch.identifier,
                            x: touch.clientX,
                            y: touch.clientY,
                            px: touch.clientX,
                            py: touch.clientY
                        });
                    }
                });
                
                this.canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        const idx = this.pointers.findIndex(p => p.id === touch.identifier);
                        
                        if (idx >= 0) {
                            const pointer = this.pointers[idx];
                            pointer.px = pointer.x;
                            pointer.py = pointer.y;
                            pointer.x = touch.clientX;
                            pointer.y = touch.clientY;
                            
                            this.addDensity(pointer.x, pointer.y, 200);
                            
                            const dx = pointer.x - pointer.px;
                            const dy = pointer.y - pointer.py;
                            this.addForce(pointer.x, pointer.y, dx, dy);
                        }
                    }
                });
                
                this.canvas.addEventListener('touchend', e => {
                    e.preventDefault();
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        const idx = this.pointers.findIndex(p => p.id === touch.identifier);
                        
                        if (idx >= 0) {
                            this.pointers.splice(idx, 1);
                        }
                    }
                });
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
            }
        }
        
        // Initialize the fluid simulation when the document is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('fluid-canvas');
            
            // Set canvas size to window size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Create and initialize the fluid simulation
            new FluidSimulation(canvas);
        });
    </script>
</body>
</html>
